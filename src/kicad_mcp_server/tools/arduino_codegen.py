"""Arduino code generation from schematic connectivity."""

import re
from pathlib import Path
from typing import Any, Dict, List, Optional
from ..server import mcp
from ..parsers.schematic_parser import SchematicParser


def detect_mcu_type(components: List[Any]) -> Optional[str]:
    """Detect MCU type from components.

    Args:
        components: List of SchematicComponent objects

    Returns:
        MCU type string or None
    """
    mcu_patterns = {
        "ESP32-S3": "esp32s3",
        "ESP32-WROOM": "esp32",
        "ESP32-C3": "esp32c3",
        "ATmega328P": "atmega328p",
        "ATmega2560": "atmega2560",
        "STM32F103": "stm32f103",
        "STM32F4": "stm32f4",
        "RP2040": "rp2040",
    }

    for comp in components:
        if comp.library_id:
            for pattern, mcu_type in mcu_patterns.items():
                if pattern in comp.library_id or pattern in comp.value:
                    return mcu_type
    return None


def parse_gpio_from_label(label: str) -> Optional[int]:
    """Extract GPIO number from label.

    Args:
        label: Label like "GPIO8", "GPIO13", etc.

    Returns:
        GPIO number or None
    """
    match = re.search(r'GPIO(\d+)', label, re.IGNORECASE)
    if match:
        return int(match.group(1))
    return None


def generate_arduino_code(
    schematic_path: str,
    output_path: Optional[str] = None
) -> str:
    """Generate Arduino code from schematic connectivity.

    Args:
        schematic_path: Path to .kicad_sch file
        output_path: Optional path to save .ino file

    Returns:
        Generated Arduino code as string
    """
    # Parse schematic
    parser = SchematicParser(schematic_path)
    components = parser.get_components()

    # Detect MCU
    mcu_type = detect_mcu_type(components)
    if not mcu_type:
        return "Error: Could not detect MCU type from schematic"

    # Analyze components and their connections
    code_lines = []
    code_lines.append(f"// Auto-generated Arduino code from KiCad schematic")
    code_lines.append(f"// MCU: {mcu_type.upper()}")
    code_lines.append(f"// Schematic: {Path(schematic_path).name}")
    code_lines.append(f"// Generated by: KiCad MCP Server")
    code_lines.append(f"")
    code_lines.append(f"#include <Arduino.h>")
    code_lines.append(f"")

    # Find I2C components (OLED, sensors, etc.)
    i2c_components = [c for c in components if any(
        kw in c.library_id.lower() for kw in ["ssd1306", "oled", "sensor", "mpu", "bme"]
    )]

    # Find SPI components
    spi_components = [c for c in components if any(
        kw in c.library_id.lower() for kw in ["sd_card", "flash", "display"]
    )]

    # Find LEDs
    leds = [c for c in components if c.reference.startswith("D") or "LED" in c.library_id]

    # Find buttons/switches
    buttons = [c for c in components if c.reference.startswith("SW") or "button" in c.library_id.lower()]

    # Generate pin definitions (would need net analysis in real implementation)
    code_lines.append(f"// ===== Pin Definitions =====")
    code_lines.append(f"")
    code_lines.append(f"// I2C Pins")
    code_lines.append(f"#define SDA_PIN 6  // Default for ESP32S3")
    code_lines.append(f"#define SCL_PIN 7  // Default for ESP32S3")
    code_lines.append(f"")

    if leds:
        code_lines.append(f"// LED Pins")
        for i, led in enumerate(leds, 1):
            code_lines.append(f"#define LED{i}_PIN {7 + i}  // {led.reference}: {led.value}")
        code_lines.append(f"")

    if buttons:
        code_lines.append(f"// Button Pins")
        for i, btn in enumerate(buttons, 1):
            code_lines.append(f"#define BUTTON{i}_PIN {9 + i}  // {btn.reference}: {btn.value}")
        code_lines.append(f"")

    # Add includes based on components
    code_lines.append(f"// ===== Library Includes =====")
    code_lines.append(f"")

    if i2c_components:
        code_lines.append(f"#include <Wire.h>")
        for comp in i2c_components:
            if "ssd1306" in comp.library_id.lower() or "oled" in comp.library_id.lower():
                code_lines.append(f"#include <Adafruit_GFX.h>")
                code_lines.append(f"#include <Adafruit_SSD1306.h>")
        code_lines.append(f"")

    # Initialize objects
    code_lines.append(f"// ===== Object Initialization =====")
    code_lines.append(f"")

    if i2c_components:
        for comp in i2c_components:
            if "ssd1306" in comp.library_id.lower():
                code_lines.append(f"#define SCREEN_WIDTH 128")
                code_lines.append(f"#define SCREEN_HEIGHT 64")
                code_lines.append(f"#define OLED_RESET -1")
                code_lines.append(f"Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);")
        code_lines.append(f"")

    # Setup function
    code_lines.append(f"// ===== Setup Function =====")
    code_lines.append(f"")
    code_lines.append(f"void setup() {{")
    code_lines.append(f"  // Initialize Serial")
    code_lines.append(f"  Serial.begin(115200);")
    code_lines.append(f"  delay(1000);")
    code_lines.append(f"  Serial.println(\"{mcu_type.upper()} Test Program\");")
    code_lines.append(f"")

    # Initialize I2C
    if i2c_components:
        code_lines.append(f"  // Initialize I2C")
        code_lines.append(f"  Wire.begin(SDA_PIN, SCL_PIN);")
        code_lines.append(f"  Serial.println(\"I2C initialized\");")
        code_lines.append(f"")

        # Initialize OLED
        for comp in i2c_components:
            if "ssd1306" in comp.library_id.lower():
                code_lines.append(f"  // Initialize OLED")
                code_lines.append(f"  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {{")
                code_lines.append(f"    Serial.println(\"SSD1306 allocation failed\");")
                code_lines.append(f"    for(;;);")
                code_lines.append(f"  }}")
                code_lines.append(f"  display.clearDisplay();")
                code_lines.append(f"  display.setTextSize(1);")
                code_lines.append(f"  display.setTextColor(SSD1306_WHITE);")
                code_lines.append(f"  display.setCursor(0,0);")
                code_lines.append(f"  display.println(\"{mcu_type.upper()} Test\");")
                code_lines.append(f"  display.println(\"OLED OK!\");")
                code_lines.append(f"  display.display();")
                code_lines.append(f"  Serial.println(\"OLED initialized\");")
                code_lines.append(f"")

    # Initialize LEDs
    if leds:
        code_lines.append(f"  // Initialize LEDs")
        for i in range(len(leds)):
            code_lines.append(f"  pinMode(LED{i+1}_PIN, OUTPUT);")
            code_lines.append(f"  digitalWrite(LED{i+1}_PIN, LOW);")
        code_lines.append(f"  Serial.println(\"LEDs initialized\");")
        code_lines.append(f"")

    # Initialize buttons
    if buttons:
        code_lines.append(f"  // Initialize Buttons")
        for i in range(len(buttons)):
            code_lines.append(f"  pinMode(BUTTON{i+1}_PIN, INPUT_PULLUP);")
        code_lines.append(f"  Serial.println(\"Buttons initialized\");")
        code_lines.append(f"")

    code_lines.append(f"  Serial.println(\"Setup complete!\");")
    code_lines.append(f"}}")
    code_lines.append(f"")

    # Loop function
    code_lines.append(f"// ===== Loop Function =====")
    code_lines.append(f"")
    code_lines.append(f"void loop() {{")

    if leds:
        code_lines.append(f"  // LED blink test")
        for i in range(len(leds)):
            code_lines.append(f"  digitalWrite(LED{i+1}_PIN, HIGH);")
            code_lines.append(f"  delay(500);")
            code_lines.append(f"  digitalWrite(LED{i+1}_PIN, LOW);")
        code_lines.append(f"  delay(500);")
    else:
        code_lines.append(f"  // Main loop")
        code_lines.append(f"  delay(1000);")

    if buttons:
        code_lines.append(f"")
        code_lines.append(f"  // Check buttons")
        for i in range(len(buttons)):
            code_lines.append(f"  if(digitalRead(BUTTON{i+1}_PIN) == LOW) {{")
            code_lines.append(f"    Serial.println(\"Button {i+1} pressed\");")
            code_lines.append(f"    delay(200);  // Debounce")
            code_lines.append(f"  }}")

    code_lines.append(f"}}")
    code_lines.append(f"")

    # Join code
    code = "\n".join(code_lines)

    # Save to file if output path provided
    if output_path:
        output = Path(output_path)
        output.write_text(code)

    return code


@mcp.tool()
async def generate_arduino_test_code(
    schematic_path: str,
    output_path: str = "",
) -> str:
    """Generate Arduino test code from schematic connectivity.

    Analyzes the schematic to detect:
    - MCU type (ESP32, STM32, Arduino, etc.)
    - I2C devices (OLED, sensors)
    - LEDs and their connections
    - Buttons and switches
    - Communication protocols

    Generates a complete Arduino .ino file with:
    - Proper library includes
    - Pin definitions
    - Setup() with initialization
    - Loop() with test routines
    - Serial debugging

    Args:
        schematic_path: Path to .kicad_sch file
        output_path: Optional path to save .ino file (e.g., "test_code/esp32s3_test.ino")

    Returns:
        Generated Arduino code and file save confirmation
    """
    try:
        path = Path(schematic_path)
        if not path.exists():
            return f"Error: Schematic file not found: {schematic_path}"

        # Generate code
        code = generate_arduino_code(schematic_path, output_path if output_path else None)

        # Save if output path provided
        if output_path:
            output = Path(output_path)
            output.parent.mkdir(parents=True, exist_ok=True)
            output.write_text(code)

            return f"""✅ Arduino test code generated successfully!

**Schematic:** {schematic_path}
**Output:** {output_path}
**Lines:** {len(code.splitlines())}

The code includes:
- Auto-detected MCU type
- I2C/SPI initialization
- Component test routines
- Serial debugging at 115200 baud

To compile and upload:
```bash
# Install Arduino CLI
# For ESP32S3:
arduino-cli compile --fqbn esp32:esp32:esp32s3 {output_path}
arduino-cli upload -p /dev/ttyUSB0 --fqbn esp32:esp32:esp32s3 {output_path}

# Monitor serial
arduino-cli monitor -p /dev/ttyUSB0 -c baudrate=115200
```

Generated code preview:
```cpp
{code[:1000]}...
```
"""

        else:
            return f"""✅ Arduino code generated (not saved)

**Schematic:** {schematic_path}
**Lines:** {len(code.splitlines())}

Generated code:
```cpp
{code}
```
"""

    except Exception as e:
        import traceback
        return f"Error generating Arduino code: {e}\n\n{traceback.format_exc()}"
